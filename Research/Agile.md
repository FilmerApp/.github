# Agile Software Development

Working together on a large software project can be tough; goals and timelines can change quickly, and you want to be able to show off your work as often as possible. This is facilitated through agile software development. These practices allow you to work in a flexible way, continuously improve both your software and your working methods, and allows you to deliver functionality often.

There are a host of different software development frameworks for working in an agile manner. I will outline two of those methods below.

# Scrum

Scrum is an agile framework designed for smaller teams to efficiently work together. In Scrum, goals are set to be completed within a small time frame, usually 2-3 weeks, called sprints. These tasks get set during a sprint planning, where the developers discuss what they want to deliver in the next sprint. Items are taken from the general backlog, and added to the sprint. During this process, the developers also discuss how much time it will take to finish each item, allowing them to better manage the required work each sprint.

Once the goals for a sprint are set, developers can start work. Every day, a short meeting is held (often called the daily scrum), usually with a set time limit, in which developers discuss their progress, identify stumbling blocks, and updates everyone on the general sprint progress.

Once a sprint is finished, the team will present and demo their work from last sprint to the stakeholders, and discusses the progress made. The goal for this demo is to only show completed work, which means it’s important to set realistic goals during the sprint planning, and create a vertical slice of your application as soon as possible.

After this presentation, the team will meet for a retrospective, reflecting on the past sprint. Identifying what went well, and what didn’t, allows the team to continuously improve the way they work together and improve their efficiency.

Crucially, scrum works with a leader within the team, the scrum master. This is someone who is part of the team, not an external manager, who is in charge of guiding the team, coaching them when needed, ensuring work proceeds smoothly, and acts as the facilitator between the team and the stakeholders. For our project, we switched between scrum masters each sprint, to allow everyone to get to grips with managing a sprint, but in reality the scrum master is usually a fixed position.

We used scrum for our own group project, which I think greatly aided cooperation and working efficiency. Because we had different teams that were dependent on our work, it was very important to deliver on time, and once we got used to working together we mostly managed to meet our sprint goals. 

Our sprint planning was a bit more loose than might usually be the case; while we did discuss what items from the backlog would be implemented each sprint, we used a Kanban board to divide tasks on a day-to-day basis.

# Kanban

Kanban is a simple agile working method built around the central pillar of a Kanban board. This is a board full of cards containing tasks (often with a short description of what that task entails) that can be assigned to different categories, for example *To Do, In Progress, Ready for Review,* and *Done*. Every card has a developer who is responsible for it, and as soon as it has been finished the next card can be taken from the top of the backlog. Often a limit is set on the amount of tasks that can be *In Progress* at the same time, ensuring every programmer has a greater focus on finishing a single task, instead of having to divide their attention across multiple.

Kanban doesn’t work with sprints, but offers continuous progress and delivery, making sure every improvement ends up deployed as soon as possible. There is no central leader for this process (although there are exceptions where a leader is appointed), but every developer has a clear overview of what needs to be done, so they can easily choose what task they will be taking on next.

Because there is no sprint where progress can be discussed, the measure of team effectiveness is often not the amount of tasks that have been completed in a period of time, but the cycle time: the average amount of time it takes to finish a task.

Kanban has many advantages: the board gives every developer a clear overview of the status of a project, and ensures everyone knows exactly what tasks still need to be done. If a limit is set on the amount of tasks that can be in progress, everyone will not just work on new features, but also be encouraged to do other jobs like reviewing each other’s code.

This flexibility could also be a downside however, as there is no central leader like a scrum-master who is responsible for the project, which means that every developer will have to take more responsibility in assigning themselves tasks and ensuring they get completed.

It’s also possible to mix Kanban with other agile working methods: for our own group project we used a sort of Kanban board, with cards divided in categories based on user stories. We did work in sprints, but every morning we had a standup where we looked at the board, discussed what tasks were completed, and assigned new ones to people who didn’t have anything to do.

Especially at the start of the semester, keeping the board updated took some getting used to, but in the end I think it turned out to be a very useful tool. The user stories being divided into multiple small tasks gave everyone a better grasp of the exact status of the project, and it was easy to identify possible bottlenecks.

# Conclusion

While we mostly used Scrum for our project, I believe the integration of the Kanban board proved very useful. This wasn’t the first time I had used agile on a group project, but I feel like I have gotten a better grasp of the method, which greatly helped our project.
